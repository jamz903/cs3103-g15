<!DOCTYPE html>
<html>

<head>
    <title>Audio Chat</title>
</head>
<style>
    #recording-indicator {
        display: none;
        color: red;
        font-weight: bold;
        margin-top: 10px;
    }
</style>

<body>
    <h1>WebSocket Audio Chat</h1>
    <h2>Your ID: <span id="ws-id"></span></h2>
    <button id="talkBtn" onmousedown="startRecording()" onmouseup="stopRecording()">Push to Talk</button>
    <h3 id="recording-indicator">Recording started</h3>
    <ul id='messages'>
    </ul>
    <script>
        var client_id = Math.floor(Math.random() * 100)
        document.querySelector("#ws-id").textContent = client_id;
        var ws;


        var mediaRecorder;
        var audioChunks = [];
        var stream;
        var recordingIndicator = document.getElementById("recording-indicator");

        async function startRecording() {
            ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`);
            ws.binaryType = 'arraybuffer';  // To handle binary audio data
            await new Promise(r => setTimeout(r, 200));

            ws.onmessage = function (event) {

                console.log(event)
                // handles the case where additional clients are trying to connect
                if (event.data == "{\"action\":\"deny\"}") {
                    alert("Someone else is speaking. Wait for your turn.");
                }
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };
            console.log("startRecording");
            // Request permission to speak by sending a "start" message
            ws.send(JSON.stringify({ action: "start" }));
            console.log("ws is sent")


            // Check if permission was granted (server responds with "start" or "deny")
            ws.onmessage = function (event) {
                var response = JSON.parse(event.data);
                console.log(response)
                if (response.action === "start") {
                    const audioContext = new AudioContext();
                    navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                        const source = audioContext.createMediaStreamSource(stream);
                        const processor = audioContext.createScriptProcessor(4096, 1, 1);

                        source.connect(processor);
                        processor.connect(audioContext.destination);
                        recordingIndicator.style.display = "block";

                        processor.onaudioprocess = (event) => {
                            const inputData = event.inputBuffer.getChannelData(0);
                            const pcmData = new Int16Array(inputData.length);
                            for (let i = 0; i < inputData.length; i++) {
                                pcmData[i] = inputData[i] * 32767;
                            }
                            if (ws.readyState == 1) {
                                ws.send(pcmData.buffer); // Send raw pcm data over websocket
                            }
                        };
                    });

                } else {
                    alert("Someone else is speaking. Wait for your turn.");
                }
            };
        }

        async function stopRecording() {

            console.log("stopRecording");
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();  // Stop the MediaRecorder
            }

            if (stream) {
                stream.getTracks().forEach(track => track.stop());  // Stop the audio stream
            }

            // ws.send(JSON.stringify({ action: "stop" }));
            // await waitForWebSocketFlush();
            ws.close()
            recordingIndicator.style.display = "none";
        }

    </script>
</body>

</html>